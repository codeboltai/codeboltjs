/**
 * Skill Optimization Script
 *
 * This script uses the Claude Agent SDK to iteratively optimize skills through:
 * 1. Generate output using a skill
 * 2. Critique the output against expected output
 * 3. Improve the skill based on critique
 * 4. Repeat for N cycles
 */

import { query } from "@anthropic-ai/claude-agent-sdk";
import fs from "fs/promises";
import path from "path";

/**
 * Configuration for the optimization process
 * @typedef {Object} OptimizationConfig
 * @property {string} prompt - The prompt to test the skill with
 * @property {string} expectedOutput - The expected output code/text
 * @property {string} skillPath - Path to the skill file (SKILL.md)
 * @property {number} cycles - Number of optimization cycles to run
 * @property {string} [outputDir] - Directory to save optimization results
 * @property {boolean} [verbose] - Enable verbose logging
 */

/**
 * Result from a single optimization cycle
 * @typedef {Object} CycleResult
 * @property {number} cycle - Cycle number
 * @property {string} generatedOutput - Output generated using the skill
 * @property {string} critique - Critique comparing generated vs expected output
 * @property {string} improvedSkill - The improved skill content
 * @property {number} score - Quality score (0-100)
 */

// /**
//  * Read skill content from file
//  * @param {string} skillPath - Path to the skill file
//  * @returns {Promise<string>} Skill content
//  */
// async function readSkill(skillPath) {
//   try {
//     return await fs.readFile(skillPath, "utf-8");
//   } catch (error) {
//     throw new Error(`Failed to read skill file: ${skillPath} - ${error.message}`);
//   }
// }

// /**
//  * Write skill content to file
//  * @param {string} skillPath - Path to the skill file
//  * @param {string} content - Skill content to write
//  */
// async function writeSkill(skillPath, content) {
//   await fs.writeFile(skillPath, content, "utf-8");
// }

/**
 * Extract the final result from query messages
 * @param {AsyncIterable} queryStream - The query stream
 * @returns {Promise<string>} The result text
 */
async function extractResult(queryStream) {
  let result = "";
  for await (const message of queryStream) {
    if ("result" in message) {
      result = message.result;
      console.log("result:", result);
    }
    // Also capture assistant messages
    if (message.type === "assistant" && message.message?.content) {
      for (const block of message.message.content) {
        if (block.type === "text") {
          console.log("text:", block.text);
          result = block.text;
        }
      }
    }
  }
  return result;
}

/**
 * Step 1: Generate output using the skill
 * @param {string} prompt - The prompt to execute
 * @param {string} workingPath - The path of the current working dir
 * @returns {Promise<string>} Generated output
 */
async function generateOutput(prompt, workingPath) {

  const stream = query({
    prompt: prompt,
    options: {
      cwd: workingPath,
      settingSources: ["user", "project"],
      allowedTools: ["Read", "Glob", "Grep", "Skill", "Write", "Bash"],
      permissionMode: "bypassPermissions",
      maxTurns: 10,
    },
  });

  return await extractResult(stream);
}

/**
 * Step 2: Critique the generated output against expected output
 * @param {string} generatedOutputPath - The path where the output generated by the skill is stored
 * @param {string} expectedOutputPath - The path where the expected output is stored
 * @param {string} prompt - The original prompt
 * @returns {Promise<{critique: string, score: number}>} Critique and score
 */
async function critiqueOutput(generatedOutputPath, expectedOutputPath, prompt) {
  const critiquePrompt = `You are an expert code reviewer tasked with comparing generated code against expected output.

## Original Prompt
${prompt}

## Generated Output Folder
\`\`\`
${generatedOutputPath}
\`\`\`

## Expected Output Folder
\`\`\`
${expectedOutputPath}
\`\`\`

## Your Task

1. Compare the generated output with the expected output
2. Identify specific issues, missing elements, or deviations
3. Rate the quality on a scale of 0-100
4. Provide actionable suggestions for improving the skill that generated this output

Format your response as:

### Score: [0-100]

### Issues Found:
- [List specific issues]

### Missing Elements:
- [List what's missing from the generated output]

### Suggestions for Skill Improvement:
- [Specific actionable suggestions to improve the skill]

### Summary:
[Brief summary of the main problems and how to fix them]`;
  console.log("Critique Prompt:", critiquePrompt);

  const stream = query({
    prompt: critiquePrompt,
    options: {
      allowedTools: ["Read", "Glob", "Grep", "Bash", "Skill"],
      permissionMode: "bypassPermissions",
      maxTurns: 3,
    },
  });

  const critique = await extractResult(stream);

  // Extract score from critique
  const scoreMatch = critique.match(/### Score:\s*(\d+)/);
  const score = scoreMatch ? parseInt(scoreMatch[1], 10) : 50;

  return { critique, score };
}

/**
 * Step 3: Improve the skill based on critique
 * @param {string} skillPath - The Skill Path which needs to be optimized.
 * @param {string} critique - The critique from step 2
 * @param {string} prompt - The original test prompt
 * @param {string} expectedOutputPath - The expected output path which should be the output
 * @param {string} generatedOutputPath - The generated output path from the previous step
 * @returns {Promise<string>} Output of Change
 */
async function improveSkill(skillPath, critique, prompt, expectedOutputPath, generatedOutputPath) {
  const improvementPrompt = `You are an expert at creating Claude Code skills. Your task is to improve a skill based on feedback.

## The Skill Path
${skillPath}

## Test Case
**Prompt:** ${prompt}

**Expected Output is at Path:**
${expectedOutputPath}

**Generated Output is at Path:**
${generatedOutputPath}

## Critique of Current Skill Performance
${critique}

## Your Task

Rewrite the skill to address the issues identified in the critique. The improved skill should:

1. Fix all the issues mentioned in the critique
2. Add missing patterns or guidelines that would help produce the expected output
3. Keep the same overall structure (frontmatter with name/description, then content)
4. Be clear, specific, and actionable
5. Include relevant code examples if helpful

Update the Skill at ${skillPath} with the improved skill content.`;

  const stream = query({
    prompt: improvementPrompt,
    options: {
      allowedTools: ["Write", "Read", "Glob", "Grep", "Bash", "Skill"],
      permissionMode: "bypassPermissions",
      maxTurns: 10,
    },
  });

  return await extractResult(stream);
}

/**
 * Save cycle results to file
 * @param {string} outputDir - Output directory
 * @param {number} cycle - Cycle number
 * @param {CycleResult} result - Cycle result
 */
async function saveCycleResult(outputDir, cycle, result) {
  const cycleDir = path.join(outputDir, `cycle-${cycle}`);
  await fs.mkdir(cycleDir, { recursive: true });

  await Promise.all([
    fs.writeFile(path.join(cycleDir, "generated-output.txt"), result.generatedOutput),
    fs.writeFile(path.join(cycleDir, "critique.md"), result.critique),
    fs.writeFile(path.join(cycleDir, "improved-skill.md"), result.improvedSkill),
    fs.writeFile(path.join(cycleDir, "metadata.json"), JSON.stringify({
      cycle: result.cycle,
      score: result.score,
      timestamp: new Date().toISOString(),
    }, null, 2)),
  ]);
}

/**
 * Main optimization function
 * @param {OptimizationConfig} config - Optimization configuration
 * @returns {Promise<CycleResult[]>} Array of results from each cycle
 */
export async function optimizeSkill(config) {
  const {
    skillName,
    prompt,
    expectedOutputPath,
    workingDirPath,
    cycles = 3,
    outputDir = "./optimization-results",
    verbose = true,
  } = config;

  const log = verbose ? console.log : () => { };
  const results = [];

  // Create output directory
  await fs.mkdir(outputDir, { recursive: true });

  // Skill Path
  let skillPath = path.join(workingDirPath, ".claude", "skills", skillName);
  let generatedOutputPath = path.join(workingDirPath, "output");

  log(`\n${"=".repeat(60)}`);
  log(`Starting Skill Optimization`);
  log(`Skill: ${skillPath}`);
  log(`Cycles: ${cycles}`);
  log(`${"=".repeat(60)}\n`);

  for (let cycle = 1; cycle <= cycles; cycle++) {
    log(`\n--- Cycle ${cycle}/${cycles} ---\n`);

    // Step 1: Generate output using current skill
    log("Step 1: Generating output with skill...");
    const generatedOutputcontent = await generateOutput(prompt, workingDirPath);
    log(`Generated ${generatedOutputcontent.length} characters of output`);

    // Step 2: Critique the output
    log("Step 2: Critiquing output against expected...");
    const { critique, score } = await critiqueOutput(generatedOutputPath, expectedOutputPath, prompt);
    log(`Score: ${score}/100`);

    // Step 3: Improve the skill
    log("Step 3: Improving skill based on critique...");
    const generateInprovingChatContent = await improveSkill(skillPath, critique, prompt, expectedOutputPath, generatedOutputPath);
    log(`Improved skill: ${generateInprovingChatContent.length} characters`);

    // Store result
    const result = {
      cycle,
      generatedOutputcontent,
      critique,
      generateInprovingChatContent,
      score,
    };
    results.push(result);

    // Save cycle results
    await saveCycleResult(outputDir, cycle, result);
    log(`Saved results to ${outputDir}/cycle-${cycle}/`);

    // // Update current skill for next cycle
    // currentSkill = improvedSkill;

    // // Early exit if score is very high
    // if (score >= 95) {
    //   log(`\nScore reached ${score}%. Stopping early.`);
    //   break;
    // }
  }

  // // Save final optimized skill
  // const finalSkillPath = path.join(outputDir, "final-skill.md");
  // await writeSkill(finalSkillPath, currentSkill);
  // log(`\nFinal optimized skill saved to: ${finalSkillPath}`);

  // Optionally update the original skill
  // await writeSkill(skillPath, currentSkill);

  // Save summary
  // const summary = {
  //   originalSkillPath: skillPath,
  //   totalCycles: results.length,
  //   scores: results.map(r => ({ cycle: r.cycle, score: r.score })),
  //   finalScore: results[results.length - 1]?.score,
  //   completedAt: new Date().toISOString(),
  // };
  // await fs.writeFile(
  //   path.join(outputDir, "summary.json"),
  //   JSON.stringify(summary, null, 2)
  // );

  // log(`\n${"=".repeat(60)}`);
  // log(`Optimization Complete`);
  // log(`Final Score: ${summary.finalScore}/100`);
  // log(`Results saved to: ${outputDir}`);
  // log(`${"=".repeat(60)}\n`);

  return results;
}

/**
 * CLI interface
 */
async function main() {
  const args = process.argv.slice(2);

  if (args.length < 3) {
    console.log(`
Skill Optimization Script

Usage: node optimize-skill.js <skill-name> <workingdir-path> <prompt-file> <expected-output-file> [options]

Arguments:
  skill-name           Name of the skill to optimize
  workingdir-path      Path to the working directory (where .claude/skills/{skill-name}/SKILL.md is present)
  prompt-file          Path to file containing the test prompt
  expected-output-path Path to folder containing expected output

Options:
  --cycles=N           Number of optimization cycles (default: 3)
  --output=DIR         Output directory for results (default: ./optimization-results)
  --quiet              Disable verbose logging

Example:
  node optimize-skill.js codebolt-agent-development ./my-skill/SKILL.md ./test-prompt.txt ./expected-output.txt --cycles=5
`);
    process.exit(1);
  }

  const skillName = args[0];
  const workingDirPath = args[1];
  const promptFile = args[2];
  const expectedOutputPath = args[3];

  // Parse options
  let cycles = 3;
  let outputDir = "./optimization-results";
  let verbose = true;

  for (const arg of args.slice(4)) {
    if (arg.startsWith("--cycles=")) {
      cycles = parseInt(arg.split("=")[1], 10);
    } else if (arg.startsWith("--output=")) {
      outputDir = arg.split("=")[1];
    } else if (arg === "--quiet") {
      verbose = false;
    }
  }

  // Read files
  const prompt = await fs.readFile(promptFile, "utf-8");

  // Run optimization
  await optimizeSkill({
    skillName,
    prompt: prompt.trim(),
    expectedOutputPath: expectedOutputPath,
    workingDirPath,
    cycles,
    outputDir,
    verbose,
  });
}

// Run CLI if executed directly
if (process.argv[1]?.endsWith("optimize-skill.js")) {
  main().catch(console.error);
}
